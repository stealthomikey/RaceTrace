<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>RaceTrace Playback: Relive Thrilling Race Moments & Driver Performance</title>
    
    <meta name="description" content="Relive the excitement of races with RaceTrace Playback. Analyze driver performance, track positions, and lap times for Lewis Hamilton, Lando Norris, and more.">
    
    <meta name="keywords" content="RaceTrace, race playback, racing analytics, F1 playback, motorsport, Lewis Hamilton, Lando Norris, lap times, driver performance, 3D race visualization">
    
    <meta property="og:title" content="RaceTrace Playback: Relive Thrilling Race Moments">
    <meta property="og:description" content="Experience detailed race playback and analyze driver performance with interactive 3D visualizations.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.racetrace.co.uk/"> <meta property="og:image" content="https://www.racetrace.co.uk/textures/logo.png"> <meta property="og:image:alt" content="RaceTrace Playback interface showing racing karts on a track">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@RaceTraceOfficial"> <meta name="twitter:creator" content="@RaceTraceOfficial"> <meta name="twitter:title" content="RaceTrace Playback: Relive Thrilling Race Moments">
    <meta name="twitter:description" content="Experience detailed race playback and analyze driver performance with interactive 3D visualizations.">
    <meta name="twitter:image" content="https://www.racetrace.co.uk/texture/logo.png"> <link rel="canonical" href="https://www.racetrace.co.uk/"> <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <style>
        /* --- Global & Session Page Styles --- */
        @import url("https://fonts.googleapis.com/css?family=DM+Sans:400,700&display=swap");

        :root {
            --black: 0;
            --white: 255;
            --theme: var(--black);
            --theme-invert: var(--white);
            
            --base-full: rgba(var(--theme),var(--theme),var(--theme),1);
            --base-60: rgba(var(--theme),var(--theme),var(--theme),0.6);
            --base-40: rgba(var(--theme),var(--theme),var(--theme),0.4);
            --base-20: rgba(var(--theme),var(--theme),var(--theme),0.2);
            --base-5: rgba(var(--theme),var(--theme),var(--theme),0.05);
            
            --invert-full: rgba(var(--theme-invert),var(--theme-invert),var(--theme-invert),1);

            --red-color: #EE3F46;
            --green: #27B768;
            --first: #F5CD75;
            --second: var(--base-60);
            --third: #C6906B;
        }

        html {
            box-sizing: border-box;
            font-size: 62.5%;
        }

        *, *:before, *:after {
            box-sizing: inherit;
        }

        body {
            font-family: 'DM Sans', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #eef1f5;
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            animation: fadeIn 1s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .page-header {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 1.5rem 0;
            text-align: center;
            border-bottom: var(--red-color) 4px solid;
        }

        .page-header h1 {
            margin: 0;
            font-size: 2.8rem;
            letter-spacing: 1px;
        }

        .page-footer {
            text-align: center;
            padding: 2.5rem;
            margin-top: auto;
            background: #2c3e50;
            color: #ecf0f1;
            font-size: 1.4rem;
        }

        .main-container {
            width: 95%;
            max-width: 1400px;
            margin: auto;
            padding: 20px;
            flex-grow: 1;
        }
        
        main {
            padding: 2.5rem;
            background: #ffffff;
            margin-top: 2.5rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            border-radius: 8px;
            display: flex;
            flex-direction: column; 
            gap: 2.5rem;
        }

        @media (min-width: 992px) {
            main {
                flex-direction: row; 
            }
            .playback-area {
                order: -1;
            }
        }
        
        .playback-area {
            flex: 3 1 700px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            min-width: 0;
        }

        .leaderboard-area {
            flex: 1 1 300px;
            min-width: 280px;
        }

        /* Leaderboard Styles */
        .leaderboard-header {
            margin-bottom: 1.6rem;
        }
        
        .main-headline-title {
            font-size: 2.5rem;
            margin: 0;
            line-height: 1.2;
        }
        .main-headline-title .title-line-1 {
            display: block;
            font-size: 1.3rem;
            color: var(--red-color);
            font-weight: 700;
        }
        .main-headline-title .title-line-2 {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            margin-top: 0.4rem;
        }
        .main-headline-title .live-race-text {
            font-size: 2.2rem;
            color: #2c3e50;
        }
        
        .custom-lap-selector-container {
            position: relative;
            display: inline-block;
        }
        .current-lap-display {
            font-size: 1.3rem;
            color: var(--base-60);
            cursor: pointer;
        }
        .current-lap-display .lap-number-underlined {
            text-decoration: underline;
        }
        .lap-dropdown-list {
            display: none;
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--invert-full);
            border: 1px solid var(--base-40);
            border-radius: 0.4rem;
            min-width: 130px;
            max-height: 180px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(var(--theme),var(--theme),var(--theme),0.1);
        }
        .lap-dropdown-list div[role="option"] {
            padding: 0.6em 0.9em;
            cursor: pointer;
            color: var(--base-full);
            font-size: 1.3rem;
            white-space: nowrap;
        }
        .lap-dropdown-list div[role="option"]:hover,
        .lap-dropdown-list div[role="option"].focused { 
            background-color: var(--base-5);
        }
        .lap-dropdown-list div[role="option"][aria-selected="true"] {
            background-color: var(--base-20); 
            font-weight: 700; 
        }

        .standings-grid {
            width: 100%;
            border-spacing: 0;
        }
        .standings-grid-data-row:nth-of-type(even) .standings-grid-data-cell {
            background: var(--base-5);
        }
        .standings-grid-header-cell {
            text-align: left; padding: 0.8rem; font-size: 1.3rem;
            border-bottom: 1px solid var(--base-40); color: var(--base-60);
        }
        .standings-grid-data-cell {
            padding: 1.2rem 0.8rem; vertical-align: middle; font-size: 1.5rem;
        }
        .driver-details small {
            opacity: 0.6; font-size: 1.2rem; display: block;
        }

        .ranking-bubble {
            display: inline-flex; border-radius: 50%; width: 3.2rem; height: 3.2rem;
            background: var(--base-20); color: var(--invert-full); 
            align-items: center; justify-content: center;
            font-size: 1.4rem; position: relative; border: 2px solid var(--base-20); 
        }
        .ranking-bubble:before { 
            content: ""; position: absolute; top: 0; bottom: 0; left: 0; right: 0;
            opacity: 0.15; border-radius: 50%;
        }
        .ranking-bubble-first { border-color: var(--first); color: var(--first); background: transparent; }
        .ranking-bubble-first:before { background: var(--first); }
        .ranking-bubble-second { border-color: var(--second); color: var(--second); background: transparent; }
        .ranking-bubble-second:before { background: var(--second); }

        .align-text-center { text-align: center !important; }
        .align-text-right { text-align: right !important; }
        
        /* Playback & Controls Styles */
        #canvas-container, #controls, #timeline {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        #canvas-container {
            width: 100%; height: 50vh; min-height: 400px; max-height: 600px;
            overflow: hidden; background: #000;
        }

        #controls, #timeline {
            background-color: #fdfdfd; padding: 1.5rem;
        }

        #controls {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem;
        }

        .control-btn {
            background: #2c3e50; color: #fff; padding: 1rem 1.8rem; border: none;
            border-radius: 5px; cursor: pointer; font-size: 1.4rem; font-weight: 500;
            text-decoration: none; text-align: center;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .control-btn:hover {
            background: #34495e; transform: translateY(-1px);
        }

        #timeline {
            display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;
        }

        #timeline-controls {
            display: flex; gap: 0.8rem;
        }
        
        #timeline-controls button {
            background: var(--red-color); color: #fff; border: none;
            border-radius: 50%; width: 36px; height: 36px; font-size: 1.6rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: background-color 0.3s ease;
        }
        #timeline-controls button:hover {
            background: #c0392b;
        }
        
        #timeline-slider-container {
            flex-grow: 1; position: relative; display: flex; align-items: center;
        }

        #timeline-slider {
            -webkit-appearance: none; appearance: none; width: 100%; height: 8px;
            background: #ddd; outline: none; border-radius: 4px; transition: opacity .2s;
        }

        #timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            background: var(--red-color); cursor: pointer; border-radius: 50%;
            border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        
        #timeline-time {
            position: absolute; top: -30px; background: #2c3e50; color: white;
            padding: 0.3rem 0.8rem; border-radius: 4px; font-size: 1.2rem;
            transform: translateX(-50%); white-space: nowrap;
        }
        
        #timeline-progress {
            position: absolute; top: 50%; transform: translateY(-50%); height: 8px;
            background-color: var(--red-color); border-radius: 4px; pointer-events: none;
        }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <header class="page-header">
        <h1>RaceTrace Playback</h1> </header>

    <div class="main-container">
        <main>
            <aside class="leaderboard-area">
                <div class="leaderboard-header">
                    <h2 class="main-headline-title"> <span class="title-line-1">FASTLANE</span>
                        <div class="title-line-2">
                            <span class="live-race-text">Race Playback</span>
                            <div id="customLapSelectorContainer" class="custom-lap-selector-container">
                                <span id="currentLapDisplay" class="current-lap-display" tabindex="0" role="button" aria-haspopup="listbox" aria-expanded="false">
                                </span>
                                <div id="lapDropdownList" class="lap-dropdown-list" role="listbox">
                                </div>
                            </div>
                        </div>
                    </h2>
                </div>
                <table class="standings-grid">
                    <caption>Current Race Standings</caption> <thead class="standings-grid-header">
                        <tr class="standings-grid-header-row">
                            <th class="standings-grid-header-cell align-text-center" scope="col">Pos</th> <th class="standings-grid-header-cell" scope="col">Driver</th> <th class="standings-grid-header-cell align-text-right" scope="col">Time / Interval</th> </tr>
                    </thead>
                    <tbody>
                        <tr class="standings-grid-data-row">
                            <td class="standings-grid-data-cell align-text-center"><span class="ranking-bubble ranking-bubble-first">1</span></td>
                            <td class="standings-grid-data-cell driver-details" id="leader-driver-details">
                                <strong>Lewis Hamilton</strong><br><small>Ferrari</small>
                            </td>
                            <td class="standings-grid-data-cell align-text-right"><strong id="leader-time">0.00s</strong></td>
                        </tr>
                        <tr class="standings-grid-data-row">
                            <td class="standings-grid-data-cell align-text-center"><span class="ranking-bubble ranking-bubble-second">2</span></td>
                            <td class="standings-grid-data-cell driver-details" id="second-driver-details">
                                <strong>Lando Norris</strong><br><small>McLaren</small>
                            </td>
                            <td class="standings-grid-data-cell align-text-right"><strong id="second-time">0.00s</strong></td>
                        </tr>
                    </tbody>
                </table>
            </aside>
            <section class="playback-area">
                <h3>Interactive Race Playback Viewer</h3> <div id="canvas-container" aria-label="3D Race Playback Arena"></div> <div id="controls" role="group" aria-label="Race Playback Controls"> <button id="birdsEyeBtn" class="control-btn" aria-label="Bird's Eye View of the Track">Bird's Eye View</button>
                    <button id="kart1Btn" class="control-btn" aria-label="View from Lewis Hamilton's Kart">Lewis Hamilton</button>
                    <button id="kart2Btn" class="control-btn" aria-label="View from Lando Norris's Kart">Lando Norris</button>
                    <button id="frontViewBtn" class="control-btn" aria-label="Front View of the Leading Kart">Front View</button>
                </div>

                <div id="timeline" role="group" aria-label="Race Timeline Controls"> <div id="timeline-controls">
                        <button id="rewindBtn" aria-label="Rewind Playback">&lt;&lt;</button>
                        <button id="playPauseBtn" aria-label="Play or Pause Playback">▶</button>
                        <button id="joinBtn" aria-label="Join Karts on Timeline">↔</button>
                        <button id="unjoinBtn" aria-label="Unjoin Karts on Timeline">↻</button>
                        <button id="fastForwardBtn" aria-label="Fast Forward Playback">&gt;&gt;</button>
                    </div>
                    <div id="timeline-slider-container">
                        <div id="timeline-progress"></div>
                        <input type="range" id="timeline-slider" min="0" value="0" class="timeline-slider" aria-label="Race Playback Timeline Slider">
                        <span id="timeline-time" aria-live="polite">0.00s</span> </div>
                </div>
            </section>
        </main>
    </div>

    <footer class="page-footer">
        <p>&copy; 2025 RaceTrace. Relive every lap.</p>
    </footer>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';
        // --- NOTE: You will need to host these coordinate files or replace them with your data ---
        import { kartCoordinates, kartLineCoordinates } from './car_cords/carA5_coordinates.js';
        import { kartTwoCoordinates, kartTwoLineCoordinates } from './car_cords/carB777_coordinates.js';
        import { outerCoordinates } from './car_cords/outer.js';
        import { innerCoordinates } from './car_cords/inner.js';

        try {
            const driverData = {
                "Red": { name: "Lewis Hamilton", team: "Ferrari" },
                "Orange": { name: "Lando Norris", team: "McLaren" }
            };

            const canvasContainer = document.getElementById('canvas-container');
            let canvasWidth = canvasContainer.clientWidth, canvasHeight = canvasContainer.clientHeight;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, canvasWidth / canvasHeight, 0.1, 5000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasWidth, canvasHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            canvasContainer.appendChild(renderer.domElement);
            camera.up.set(0,0,1);

            window.addEventListener('resize', onWindowResize, false);
            function onWindowResize() {
                if (canvasContainer.clientWidth !== canvasWidth || canvasContainer.clientHeight !== canvasHeight) {
                    canvasWidth = canvasContainer.clientWidth;
                    canvasHeight = canvasContainer.clientHeight;
                    camera.aspect = canvasWidth / canvasHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(canvasWidth, canvasHeight);
                    updateTimelineDisplay();
                }
            }

            const timingGates = [];
            const numPossibleGates = Math.min(outerCoordinates.length, innerCoordinates.length);
            for (let i = 0; i < numPossibleGates; i++) {
                timingGates.push({p1: { x: outerCoordinates[i].x, y: outerCoordinates[i].y }, p2: { x: innerCoordinates[i].x, y: innerCoordinates[i].y }, name: `Gate ${i}`});
            }
            if (timingGates.length > 0) timingGates[0].name = "Start/Finish";

            // --- Helper function to create an offset path for track limits ---
            function createOffsetCurve(points, offset) {
                if (!points || points.length < 3) return [];
                const offsetPoints = [];
                const vec_p = points.map(p => new THREE.Vector2(p.x, p.y));

                for (let i = 0; i < vec_p.length; i++) {
                    const p_prev = vec_p[(i - 1 + vec_p.length) % vec_p.length];
                    const p_curr = vec_p[i];
                    const p_next = vec_p[(i + 1) % vec_p.length];

                    const v_in = new THREE.Vector2().subVectors(p_curr, p_prev).normalize();
                    const v_out = new THREE.Vector2().subVectors(p_next, p_curr).normalize();

                    const n_in = new THREE.Vector2(-v_in.y, v_in.x);
                    const n_out = new THREE.Vector2(-v_out.y, v_out.x);
                    
                    const miter_dir = new THREE.Vector2().addVectors(n_in, n_out).normalize();
                    
                    const cos_angle = v_in.dot(v_out);
                    // Clamp to avoid Math.sqrt of negative number
                    const cos_half_angle = Math.sqrt(Math.max(0, (cos_angle + 1) / 2));
                    
                    if (cos_half_angle < 0.0001) {
                        const new_point = new THREE.Vector2().addVectors(p_curr, n_out.multiplyScalar(offset));
                        offsetPoints.push({ x: new_point.x, y: new_point.y });
                        continue;
                    }

                    const miter_len = offset / cos_half_angle;

                    const offset_vec = miter_dir.multiplyScalar(miter_len);
                    const new_point = new THREE.Vector2().addVectors(p_curr, offset_vec);
                    
                    offsetPoints.push({ x: new_point.x, y: new_point.y });
                }
                return offsetPoints;
            }

            function createTrack(outerCoords, innerCoords) {
                const texLoader = new THREE.TextureLoader();
                const asphalt = texLoader.load('textures/asphalt.jpg', () => renderer.render(scene, camera));
                asphalt.wrapS = asphalt.wrapT = THREE.RepeatWrapping; asphalt.repeat.set(0.1, 0.1);
                const shape = new THREE.Shape();
                if (outerCoords.length > 0) {
                    shape.moveTo(outerCoords[0].x, outerCoords[0].y);
                    for (let i = 1; i < outerCoords.length; i++) shape.lineTo(outerCoords[i].x, outerCoords[i].y);
                }
                if (innerCoords.length > 0) {
                    const hole = new THREE.Path();
                    hole.moveTo(innerCoords[0].x, innerCoords[0].y);
                    for (let i = 1; i < innerCoords.length; i++) hole.lineTo(innerCoords[i].x, innerCoords[i].y);
                    shape.holes.push(hole);
                }
                const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.5, bevelEnabled: false });
                const mat = new THREE.MeshStandardMaterial({ map: asphalt, metalness: 0.1, roughness: 0.9 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.receiveShadow = true;
                return mesh;
            }
            scene.add(createTrack(outerCoordinates, innerCoordinates));
            
            // --- Soft Cylindrical Grid ---

            const gridGroup = new THREE.Group();
            const lineMaterial = new THREE.MeshBasicMaterial({
            color: 0xdddddd,
            transparent: true, // Enable transparency
            opacity: 0.95        // 5% transparent (95% opaque)
            });

            const spacing = 50;
            const size = 5000;
            const halfSize = size / 2;
            const zOffset = 0.01;      // Place grid slightly in front of the wall
            const cylinderRadius = 0.1; // How thick the lines are

            // Vertical cylinders (constant X, varying Y)
            for (let x = -halfSize; x <= halfSize; x += spacing) {
            // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)
            const geo = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, size, 8);
            const cylinder = new THREE.Mesh(geo, lineMaterial);

            // Position the cylinder at the correct 'x' and in the middle of the 'y' axis
            cylinder.position.set(x, 0, zOffset);
            
            gridGroup.add(cylinder);
            }

            // Horizontal cylinders (constant Y, varying X)
            for (let y = -halfSize; y <= halfSize; y += spacing) {
            const geo = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, size, 8);
            const cylinder = new THREE.Mesh(geo, lineMaterial);

            // Position the cylinder
            cylinder.position.set(0, y, zOffset);
            
            // Rotate the cylinder to be horizontal
            cylinder.rotation.z = Math.PI / 2;

            gridGroup.add(cylinder);
            }

            scene.add(gridGroup);

            // Your wall (originally called floor)
            const floorGeo = new THREE.PlaneGeometry(5000, 5000);
            const floorMat = new THREE.MeshStandardMaterial({
            color: 0x483C6C,
            metalness: 0.1,
            roughness: 0.9,
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.y = 0; // Centered vertically at 0
            // No rotation means it stays upright in the XY plane
            scene.add(floor);

            scene.background = new THREE.Color(0x483C6C); // Sky blue background

            const KART_LINE_COLORS = { red: 0xDD7777, orange: 0xFFB366 };
            function createFlatRacingLine(path, color, width) {
                const pts = path.map(c => new THREE.Vector3(c.x, c.y, 0.58));
                if (pts.length < 2) return new THREE.Group();
                const verts = [], inds = [];
                for (let i = 0; i < pts.length; i++) {
                    const curr = pts[i], next = pts[(i + 1) % pts.length];
                    const dir = new THREE.Vector3().subVectors(next, curr).normalize();
                    const norm = new THREE.Vector3(-dir.y, dir.x, 0).multiplyScalar(width / 2);
                    verts.push( curr.x + norm.x, curr.y + norm.y, curr.z, curr.x - norm.x, curr.y - norm.y, curr.z );
                }
                for (let i = 0; i < pts.length; i++) {
                    const c1 = i * 2, c2 = i * 2 + 1, n1 = ((i + 1) % pts.length) * 2, n2 = ((i + 1) % pts.length) * 2 + 1;
                    inds.push(c1, c2, n1, c2, n2, n1);
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
                geo.setIndex(inds);
                return new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide }));
            }

            // --- Function to create track limit lines on the tarmac ---
            function createTrackLimitLine(path, color, width) {
                const pts = path.map(c => new THREE.Vector3(c.x, c.y, 0.51)); // Z-value just above the track surface
                if (pts.length < 2) return new THREE.Group();
                const verts = [], inds = [];
                for (let i = 0; i < pts.length; i++) {
                    const curr = pts[i], next = pts[(i + 1) % pts.length];
                    const dir = new THREE.Vector3().subVectors(next, curr).normalize();
                    const norm = new THREE.Vector3(-dir.y, dir.x, 0).multiplyScalar(width / 2);
                    verts.push( curr.x + norm.x, curr.y + norm.y, curr.z, curr.x - norm.x, curr.y - norm.y, curr.z );
                }
                for (let i = 0; i < pts.length; i++) {
                    const c1 = i * 2, c2 = i * 2 + 1, n1 = ((i + 1) % pts.length) * 2, n2 = ((i + 1) % pts.length) * 2 + 1;
                    inds.push(c1, c2, n1, c2, n2, n1);
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
                geo.setIndex(inds);
                return new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide }));
            }

            // --- Add Track Limit Lines ---
            const trackLimitWidth = 0.8; // Line width is 1 unit.
            const gapFromEdge = 0.5; // A small gap between the track edge and the line.
            const centerlineOffset = gapFromEdge + (trackLimitWidth / 2); // Total offset for the line's center is 1.0 unit

            // For the outer boundary, offset inwards from the edge.
            const outerLineCenterline = createOffsetCurve(outerCoordinates, -centerlineOffset);
            // For the inner boundary, offset outwards from the edge (which is inwards into the tarmac).
            const innerLineCenterline = createOffsetCurve(innerCoordinates, centerlineOffset);

            scene.add(createTrackLimitLine(outerLineCenterline, 0xffffff, trackLimitWidth));
            scene.add(createTrackLimitLine(innerLineCenterline, 0xffffff, trackLimitWidth));


            if (kartLineCoordinates.length > 0) scene.add(createFlatRacingLine(kartLineCoordinates, KART_LINE_COLORS.red, 0.8));
            if (kartTwoLineCoordinates.length > 0) scene.add(createFlatRacingLine(kartTwoLineCoordinates, KART_LINE_COLORS.orange, 0.8));
            
            const rotationOffset = -1.5708;

            function calculateInitialAngle(coords, defaultAngle = 0) {
                if (coords && coords.length > 1) {
                    const dx = coords[1].x - coords[0].x, dy = coords[1].y - coords[0].y;
                    if (Math.hypot(dx * dx + dy * dy) > 0.01) return Math.atan2(dy, dx);
                }
                return defaultAngle;
            }

            let redBlock, orangeBlock;
            let adjustedRedCoords = [...kartCoordinates], adjustedOrangeCoords = [...kartTwoCoordinates];
            let redTargetAngle = calculateInitialAngle(adjustedRedCoords), orangeTargetAngle = calculateInitialAngle(adjustedOrangeCoords);
            
            function createKart(modelPath, callback, colorName) {
                const loader = new GLTFLoader();
                loader.load( modelPath, gltf => {
                        const k = gltf.scene; k.scale.set(0.7, 0.7, 0.7); k.rotation.set(1.5708, -1.5708, 0);
                        k.traverse(n => { if (n.isMesh) n.castShadow = true; });
                        scene.add(k); callback(k);
                    }, undefined, e => {
                        console.error(`Error loading ${modelPath}:`, e);
                        const g = new THREE.BoxGeometry(3.35, 1.35, 1.85);
                        const m = new THREE.MeshStandardMaterial({ color: (colorName === 'red' ? KART_LINE_COLORS.red : KART_LINE_COLORS.orange) });
                        const b = new THREE.Mesh(g, m); b.rotation.set(1.5708, -1.5708, 0); b.castShadow = true;
                        scene.add(b); callback(b);
                    }
                );
            }

            createKart('kart.glb', k => {
                redBlock = k; 
                if (adjustedRedCoords.length > 0) {
                    redBlock.position.set(adjustedRedCoords[0].x, adjustedRedCoords[0].y, 0.67);
                }
            }, 'red');

            createKart('kart2.glb', k => {
                orangeBlock = k;
                if (adjustedOrangeCoords.length > 0) {
                    orangeBlock.position.set(adjustedOrangeCoords[0].x, adjustedOrangeCoords[0].y, 0.67);
                }
            }, 'orange');

            const ambLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambLight);
            const dirLight = new THREE.DirectionalLight(0xffe0b2, 1.0);
            dirLight.position.set(100, 50, 100); dirLight.castShadow = true; dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);

            camera.position.set(0, -200, 300); camera.lookAt(0, 0, 0);

            let elapsedTime = 0;
            const lapDurRed = kartCoordinates.length > 0 ? kartCoordinates[kartCoordinates.length - 1].time : 30;
            const lapDurOrange = kartTwoCoordinates.length > 0 ? kartTwoCoordinates[kartTwoCoordinates.length - 1].time : 30;
            const resetDelay = 2.0;
            let adjustedMaxLapDuration = Math.max(lapDurRed, lapDurOrange) + resetDelay;

            let currentView = 'birdsEye', lastRedGate = -1, lastOrangeGate = -1, isScrubbing = false;
            let isPaused = true, isResetting = false, resetStartTime = 0, lastTimestamp = performance.now();
            let camTargetPos = new THREE.Vector3(), camTargetLook = new THREE.Vector3(), camTransActive = false;
            const camTransDur = 0.5; let camTransStart = 0;
            let camInitPos = new THREE.Vector3(), camInitLook = new THREE.Vector3(), camInitUp = new THREE.Vector3(0,0,1), camInitUpTarget = new THREE.Vector3(0,0,1);

            const leaderDriverCell = document.getElementById('leader-driver-details'), secondDriverCell = document.getElementById('second-driver-details');
            const leaderTimeDOM = document.getElementById('leader-time'), secondTimeDOM = document.getElementById('second-time');
            const timelineSliderEl = document.getElementById('timeline-slider'), timelineProgressEl = document.getElementById('timeline-progress'), timelineTimeEl = document.getElementById('timeline-time');
            const playPauseBtn = document.getElementById('playPauseBtn'), rewindBtn = document.getElementById('rewindBtn'), fastForwardBtn = document.getElementById('fastForwardBtn');
            const joinBtn = document.getElementById('joinBtn'), unjoinBtn = document.getElementById('unjoinBtn');

            timelineSliderEl.max = adjustedMaxLapDuration * 1000; timelineSliderEl.value = 0; playPauseBtn.innerHTML = '▶';

            function computeGateCrossings(path, gates) {
                const crossingTimes = new Array(gates.length).fill(null);
                if (!path || path.length < 2 || !gates || gates.length === 0) return crossingTimes;
                if (gates.length > 0 && path.length > 0 && path[0].time === 0) {
                    const p0 = path[0], g0 = gates[0]; if (Math.hypot(p0.x - g0.p1.x, p0.y - g0.p1.y) < 1) crossingTimes[0] = 0;
                } else if (gates.length > 0) crossingTimes[0] = 0;
                let gateIdx = 1;
                for (let i = 0; i < path.length - 1 && gateIdx < gates.length; i++) {
                    const p1 = path[i], p2 = path[i + 1], t1 = p1.time, t2 = p2.time, gate = gates[gateIdx];
                    const dx = gate.p2.x - gate.p1.x, dy = gate.p2.y - gate.p1.y, len = Math.hypot(dx,dy);
                    if (len === 0) continue;
                    const cx = (gate.p1.x + gate.p2.x) / 2, cy = (gate.p1.y + gate.p2.y) / 2, halfLen = (len * 3) / 2, dirX = dx / len, dirY = dy / len;
                    const extP1 = { x: cx - dirX * halfLen, y: cy - dirY * halfLen }, extP2 = { x: cx + dirX * halfLen, y: cy + dirY * halfLen };
                    if (segmentsIntersect(p1.x, p1.y, p2.x, p2.y, extP1.x, extP1.y, extP2.x, extP2.y)) {
                        const denom = (p1.x-p2.x)*(extP1.y-extP2.y)-(p1.y-p2.y)*(extP1.x-extP2.x);
                        if(Math.abs(denom) > 1e-8) crossingTimes[gateIdx] = t1 + (((p1.x-extP1.x)*(extP1.y-extP2.y)-(p1.y-extP1.y)*(extP1.x-extP2.x))/denom)*(t2-t1);
                        gateIdx++; i--;
                    }
                }
                return crossingTimes;
            }

            let redGateCrossingTimes = computeGateCrossings(adjustedRedCoords, timingGates), orangeGateCrossingTimes = computeGateCrossings(adjustedOrangeCoords, timingGates);

            function setCameraView(view) {
                if (currentView === view && !camTransActive) return;
                currentView = view; camTransActive = true; camTransStart = performance.now() / 1000;
                camInitPos.copy(camera.position); const lookAt = new THREE.Vector3();
                camera.getWorldDirection(lookAt).multiplyScalar(10).add(camera.position);
                camInitLook.copy(lookAt); camInitUp.copy(camera.up); updateCameraTarget();
            }

            function updateCameraTarget() {
                let newTargetUp = new THREE.Vector3(0,0,1);
                if (currentView === 'birdsEye') { camTargetPos.set(500, 300, 1200); camTargetLook.set(500,300,0); newTargetUp.set(0,1,0); } 
                else if ((currentView === 'kart1' && redBlock) || (currentView === 'kart2' && orangeBlock)) {
                    const kart = (currentView === 'kart1') ? redBlock : orangeBlock;
                    const angle = kart.rotation.y - rotationOffset, dirX = Math.cos(angle), dirY = Math.sin(angle);
                    camTargetPos.set(kart.position.x - dirX * 12, kart.position.y - dirY * 12, kart.position.z + 4);
                    camTargetLook.set(kart.position.x, kart.position.y, kart.position.z + 0.5);
                } else if (currentView === 'frontView') {
                    let leaderKart = (lastOrangeGate > lastRedGate || (lastOrangeGate === lastRedGate && orangeGateCrossingTimes[lastOrangeGate] < redGateCrossingTimes[lastRedGate])) ? orangeBlock : redBlock;
                    if(leaderKart) {
                        const angle = leaderKart.rotation.y - rotationOffset, dirX = Math.cos(angle), dirY = Math.sin(angle);
                        camTargetPos.set(leaderKart.position.x + dirX * 10, leaderKart.position.y + dirY * 10, leaderKart.position.z + 3);
                        camTargetLook.set(leaderKart.position.x, leaderKart.position.y, leaderKart.position.z + 0.5);
                    } else { camTargetPos.set(0, -150, 250); camTargetLook.set(0,0,0); newTargetUp.set(0,1,0); }
                }
                camInitUpTarget.copy(newTargetUp);
            }

            document.getElementById('birdsEyeBtn').addEventListener('click', () => setCameraView('birdsEye'));
            document.getElementById('kart1Btn').addEventListener('click', () => setCameraView('kart1'));
            document.getElementById('kart2Btn').addEventListener('click', () => setCameraView('kart2'));
            document.getElementById('frontViewBtn').addEventListener('click', () => setCameraView('frontView'));

            timelineSliderEl.addEventListener('input', e => {
                isScrubbing = true; elapsedTime = parseFloat(e.target.value) / 1000; updateResetStateAndGatesForElapsedTime();
                updateKartVisualsAndLogicalState(elapsedTime); updateTimelineDisplay();
            });
            timelineSliderEl.addEventListener('change', () => {
                isScrubbing = false; updateResetStateAndGatesForElapsedTime(); updateKartVisualsAndLogicalState(elapsedTime);
                if (!isPaused) lastTimestamp = performance.now();
            });

            function updateResetStateAndGatesForElapsedTime() {
                const maxTimeRed = adjustedRedCoords.length > 0 ? adjustedRedCoords[adjustedRedCoords.length-1].time : 0;
                const maxTimeOrange = adjustedOrangeCoords.length > 0 ? adjustedOrangeCoords[adjustedOrangeCoords.length-1].time : 0;
                const overallMaxTime = Math.max(maxTimeRed, maxTimeOrange);
                if (elapsedTime >= overallMaxTime && elapsedTime < overallMaxTime + resetDelay && overallMaxTime > 0) {
                    isResetting = true;
                    resetStartTime = (isPaused || isScrubbing ? elapsedTime : performance.now() / 1000) - (elapsedTime - overallMaxTime);
                } else if (elapsedTime >= overallMaxTime + resetDelay && overallMaxTime > 0) {
                    isResetting = false; elapsedTime = 0; timelineSliderEl.value = 0; if (!isPaused) lastTimestamp = performance.now();
                    unjoinBtn.click(); isPaused = true; playPauseBtn.innerHTML = '▶';
                } else isResetting = false;
            }

            playPauseBtn.addEventListener('click', () => { isPaused = !isPaused; playPauseBtn.innerHTML = isPaused ? '▶' : '⏸'; if (!isPaused) lastTimestamp = performance.now(); });
            rewindBtn.addEventListener('click', () => { elapsedTime = Math.max(0, elapsedTime-1); updateResetStateAndGatesForElapsedTime(); updateKartVisualsAndLogicalState(elapsedTime); timelineSliderEl.value = elapsedTime*1000; updateTimelineDisplay(); });
            fastForwardBtn.addEventListener('click', () => { elapsedTime = Math.min(adjustedMaxLapDuration, elapsedTime+1); updateResetStateAndGatesForElapsedTime(); updateKartVisualsAndLogicalState(elapsedTime); timelineSliderEl.value = elapsedTime*1000; updateTimelineDisplay(); });

            // --- START OF UNALTERED BUTTON LOGIC FROM workinglogic.html ---
            joinBtn.addEventListener('click', () => {
                if (!redBlock || !orangeBlock || kartCoordinates.length === 0 || kartTwoCoordinates.length === 0) {
                    console.warn("Cannot join: Kart models or original paths not ready."); return;
                }
                let leaderOriginalCoords, followerOriginalCoords, leaderAdjustedCoords, followerAdjustedCoords, leaderKartBlock, followerKartBlock, leaderLapDuration, followerLapDuration;
                let isRedCurrentlyLeader;

                if (lastRedGate === -1 && lastOrangeGate === -1) { isRedCurrentlyLeader = true; }
                else if (lastRedGate === -1) { isRedCurrentlyLeader = false; } else if (lastOrangeGate === -1) { isRedCurrentlyLeader = true; }
                else {
                    if (lastOrangeGate > lastRedGate) { isRedCurrentlyLeader = false; }
                    else if (lastRedGate > lastOrangeGate) { isRedCurrentlyLeader = true; }
                    else { isRedCurrentlyLeader = (redGateCrossingTimes[lastRedGate] != null && orangeGateCrossingTimes[lastOrangeGate] != null && redGateCrossingTimes[lastRedGate] <= orangeGateCrossingTimes[lastOrangeGate]); }
                }

                if (isRedCurrentlyLeader) {
                    leaderOriginalCoords = kartCoordinates; followerOriginalCoords = kartTwoCoordinates; leaderAdjustedCoords = adjustedRedCoords; followerAdjustedCoords = adjustedOrangeCoords; leaderKartBlock = redBlock; followerKartBlock = orangeBlock; leaderLapDuration = lapDurRed; followerLapDuration = lapDurOrange;
                } else {
                    leaderOriginalCoords = kartTwoCoordinates; followerOriginalCoords = kartCoordinates; leaderAdjustedCoords = adjustedOrangeCoords; followerAdjustedCoords = adjustedRedCoords; leaderKartBlock = orangeBlock; followerKartBlock = redBlock; leaderLapDuration = lapDurOrange; followerLapDuration = lapDurRed;
                }
                let leaderCurrentX, leaderCurrentY, leaderCurrentAngle; let leaderPosFound = false;
                if (leaderAdjustedCoords.length > 0) {
                    for (let i = 0; i < leaderAdjustedCoords.length - 1; i++) {
                        const currT = leaderAdjustedCoords[i].time; const nextT = leaderAdjustedCoords[i + 1].time;
                        if (elapsedTime >= currT && elapsedTime <= nextT) {
                            const frac = (nextT === currT) ? 0 : (elapsedTime - currT) / (nextT - currT);
                            leaderCurrentX = THREE.MathUtils.lerp(leaderAdjustedCoords[i].x, leaderAdjustedCoords[i + 1].x, frac);
                            leaderCurrentY = THREE.MathUtils.lerp(leaderAdjustedCoords[i].y, leaderAdjustedCoords[i + 1].y, frac);
                            const dx = leaderAdjustedCoords[i+1].x - leaderAdjustedCoords[i].x; const dy = leaderAdjustedCoords[i+1].y - leaderAdjustedCoords[i].y;
                            if (Math.hypot(dx, dy) > 0.01) leaderCurrentAngle = Math.atan2(dy, dx); else leaderCurrentAngle = (isRedCurrentlyLeader ? redTargetAngle : orangeTargetAngle);
                            leaderPosFound = true; break;
                        }
                    }
                    if (!leaderPosFound) { if (elapsedTime >= leaderAdjustedCoords[leaderAdjustedCoords.length-1].time && leaderAdjustedCoords.length>0) { leaderCurrentX = leaderAdjustedCoords[leaderAdjustedCoords.length - 1].x; leaderCurrentY = leaderAdjustedCoords[leaderAdjustedCoords.length - 1].y; if (leaderAdjustedCoords.length > 1) { const dx = leaderAdjustedCoords[leaderAdjustedCoords.length-1].x - leaderAdjustedCoords[leaderAdjustedCoords.length-2].x; const dy = leaderAdjustedCoords[leaderAdjustedCoords.length-1].y - leaderAdjustedCoords[leaderAdjustedCoords.length-2].y; if (Math.hypot(dx, dy) > 0.01) leaderCurrentAngle = Math.atan2(dy, dx); else leaderCurrentAngle = (isRedCurrentlyLeader ? redTargetAngle : orangeTargetAngle); } else { leaderCurrentAngle = (isRedCurrentlyLeader ? redTargetAngle : orangeTargetAngle); }} else if (leaderAdjustedCoords.length>0) { leaderCurrentX = leaderAdjustedCoords[0].x; leaderCurrentY = leaderAdjustedCoords[0].y; if (leaderAdjustedCoords.length > 1) { const dx = leaderAdjustedCoords[1].x - leaderAdjustedCoords[0].x; const dy = leaderAdjustedCoords[1].y - leaderAdjustedCoords[0].y; if (Math.hypot(dx, dy) > 0.01) leaderCurrentAngle = Math.atan2(dy, dx); else leaderCurrentAngle = (isRedCurrentlyLeader ? redTargetAngle : orangeTargetAngle); } else { leaderCurrentAngle = (isRedCurrentlyLeader ? redTargetAngle : orangeTargetAngle); }} else return; }
                } else return;
                let minDistanceSq = Infinity; let closestPointIndexOnFollowerOriginalPath = 0; let followerNewStartX, followerNewStartY;
                for (let i = 0; i < followerOriginalCoords.length; i++) { const pt = followerOriginalCoords[i]; const dx = pt.x - leaderCurrentX; const dy = pt.y - leaderCurrentY; const distanceSq = dx * dx + dy * dy; if (distanceSq < minDistanceSq) { minDistanceSq = distanceSq; closestPointIndexOnFollowerOriginalPath = i; followerNewStartX = pt.x; followerNewStartY = pt.y; }}
                if (followerNewStartX === undefined) return;
                const newFollowerPath = []; newFollowerPath.push({ x: followerNewStartX, y: followerNewStartY, time: elapsedTime }); let lastTimeInNewPath = elapsedTime;
                for (let i = 1; i < followerOriginalCoords.length; i++) { const currentOriginalIdx = (closestPointIndexOnFollowerOriginalPath + i) % followerOriginalCoords.length; const prevOriginalIdx = (closestPointIndexOnFollowerOriginalPath + i - 1 + followerOriginalCoords.length) % followerOriginalCoords.length; const originalPoint = followerOriginalCoords[currentOriginalIdx]; const prevOriginalPoint = followerOriginalCoords[prevOriginalIdx]; let timeInterval = originalPoint.time - prevOriginalPoint.time; if (timeInterval < 0) timeInterval += followerLapDuration; timeInterval = Math.max(0.001, timeInterval); const newTime = lastTimeInNewPath + timeInterval; newFollowerPath.push({ x: originalPoint.x, y: originalPoint.y, time: newTime }); lastTimeInNewPath = newTime; }
                newFollowerPath.sort((a, b) => a.time - b.time);
                let newFollowerAngleForVisuals; if (newFollowerPath.length > 1) { const dx = newFollowerPath[1].x - newFollowerPath[0].x; const dy = newFollowerPath[1].y - newFollowerPath[0].y; newFollowerAngleForVisuals = (Math.hypot(dx, dy) > 0.01) ? Math.atan2(dy, dx) : leaderCurrentAngle; } else { newFollowerAngleForVisuals = leaderCurrentAngle; }
                followerKartBlock.position.set(followerNewStartX, followerNewStartY, 0.67); followerKartBlock.rotation.y = newFollowerAngleForVisuals + rotationOffset;
                if (isRedCurrentlyLeader) {
                    adjustedOrangeCoords = newFollowerPath;
                    orangeTargetAngle = newFollowerAngleForVisuals;
                    orangeGateCrossingTimes = computeGateCrossings(adjustedOrangeCoords, timingGates);
                } else {
                    adjustedRedCoords = newFollowerPath;
                    redTargetAngle = newFollowerAngleForVisuals;
                    redGateCrossingTimes = computeGateCrossings(adjustedRedCoords, timingGates);
                }
                const leaderFinalTime = leaderAdjustedCoords.length > 0 ? leaderAdjustedCoords[leaderAdjustedCoords.length -1].time : 0;
                const followerFinalTime = newFollowerPath.length > 0 ? newFollowerPath[newFollowerPath.length -1].time : 0;
                adjustedMaxLapDuration = Math.max(leaderFinalTime, followerFinalTime) + resetDelay; timelineSliderEl.max = adjustedMaxLapDuration * 1000;
                updateKartVisualsAndLogicalState(elapsedTime); updateTimelineDisplay(); if (!isPaused && !isScrubbing) lastTimestamp = performance.now();
            });

            unjoinBtn.addEventListener('click', () => {
                adjustedRedCoords = [...kartCoordinates]; adjustedOrangeCoords = [...kartTwoCoordinates];
                redGateCrossingTimes = computeGateCrossings(adjustedRedCoords, timingGates);
                orangeGateCrossingTimes = computeGateCrossings(adjustedOrangeCoords, timingGates, "orange");
                elapsedTime = 0; timelineSliderEl.value = 0; lastRedGate = -1; lastOrangeGate = -1;
                lastTimestamp = performance.now(); isPaused = false; isResetting = false; playPauseBtn.innerHTML = '⏸';
                redTargetAngle = calculateInitialAngle(adjustedRedCoords); if (redBlock && adjustedRedCoords.length > 0) { redBlock.position.set(adjustedRedCoords[0].x, adjustedRedCoords[0].y, 0.67); redBlock.rotation.y = redTargetAngle + rotationOffset; }
                orangeTargetAngle = calculateInitialAngle(adjustedOrangeCoords); if (orangeBlock && adjustedOrangeCoords.length > 0) { orangeBlock.position.set(adjustedOrangeCoords[0].x, adjustedOrangeCoords[0].y, 0.67); orangeBlock.rotation.y = orangeTargetAngle + rotationOffset; }
                adjustedMaxLapDuration = Math.max(lapDurRed, lapDurOrange) + resetDelay; timelineSliderEl.max = adjustedMaxLapDuration * 1000;
                updateKartVisualsAndLogicalState(elapsedTime); updateTimelineDisplay();
            });
            // --- END OF UNALTERED BUTTON LOGIC ---

            function updateTimelineDisplay() {
                const container = timelineSliderEl.parentElement; if (!container) return;
                const clampedTime = Math.max(0, Math.min(elapsedTime, adjustedMaxLapDuration));
                const ratio = (adjustedMaxLapDuration > 0) ? (clampedTime / adjustedMaxLapDuration) : 0;
                const trackWidth = timelineSliderEl.clientWidth;
                timelineProgressEl.style.width = `${ratio * trackWidth}px`;
                timelineTimeEl.textContent = `${clampedTime.toFixed(2)}s`;
                const thumbWidth = 20, textWidth = timelineTimeEl.offsetWidth;
                const thumbCenter = ratio * (trackWidth - thumbWidth) + (thumbWidth / 2);
                timelineTimeEl.style.left = `${Math.max(0, Math.min(thumbCenter - (textWidth / 2), container.clientWidth - textWidth))}px`;
            }

            function lerpAngle(c, t, a) { let d = t - c; while (d > Math.PI) d -= 2 * Math.PI; while (d < -Math.PI) d += 2 * Math.PI; return c + d * a; }
            function segmentsIntersect(p1x,p1y,q1x,q1y,p2x,p2y,q2x,q2y){function o(p,q,r){const v=(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);if(v===0)return 0;return(v>0)?1:2;}function on(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y);}const p1={x:p1x,y:p1y},q1={x:q1x,y:q1y},p2={x:p2x,y:p2y},q2={x:q2x,y:q2y};const o1=o(p1,q1,p2),o2=o(p1,q1,q2),o3=o(p2,q2,p1),o4=o(p2,q2,q1);if(o1!==o2&&o3!==o4)return true;if(o1===0&&on(p1,p2,q1))return true;if(o2===0&&on(p1,q2,q1))return true;if(o3===0&&on(p2,p1,q2))return true;if(o4===0&&on(p2,q1,q2))return true;return false;}

            function updateKartVisualsAndLogicalState(currentTime) {
                [redBlock, orangeBlock].forEach((kart, index) => {
                    if (!kart) return;
                    const path = index === 0 ? adjustedRedCoords : adjustedOrangeCoords; let targetAngle = index === 0 ? redTargetAngle : orangeTargetAngle;
                    if (!isResetting && path.length > 0) {
                        let x=path[0].x, y=path[0].y; let found = false;
                        for (let i = 0; i < path.length-1; i++) {
                            if (currentTime >= path[i].time && currentTime <= path[i+1].time) {
                                const fr = (path[i+1].time === path[i].time) ? 0 : (currentTime - path[i].time) / (path[i+1].time-path[i].time);
                                x = THREE.MathUtils.lerp(path[i].x, path[i+1].x, fr); y = THREE.MathUtils.lerp(path[i].y, path[i+1].y, fr);
                                targetAngle = Math.atan2(path[i+1].y-path[i].y, path[i+1].x-path[i].x); found = true; break;
                            }
                        }
                        if (!found && currentTime > path[0].time) { x = path[path.length-1].x; y = path[path.length-1].y; }
                        kart.position.set(x, y, 0.67); kart.rotation.y = lerpAngle(kart.rotation.y, targetAngle + rotationOffset, (isScrubbing || isPaused) ? 1.0 : 0.15);
                        if (index === 0) redTargetAngle = targetAngle; else orangeTargetAngle = targetAngle;
                    }
                });
            }

            function animate(timestamp) {
                requestAnimationFrame(animate);
                if (!redBlock || !orangeBlock) return;
                
                if (!isScrubbing && !isPaused) {
                    elapsedTime += (timestamp - lastTimestamp) / 1000; lastTimestamp = timestamp; updateResetStateAndGatesForElapsedTime();
                    if (!isResetting) timelineSliderEl.value = elapsedTime * 1000;
                }
                
                updateKartVisualsAndLogicalState(elapsedTime);
                updateTimelineDisplay();
                
                // --- START OF UNALTERED TIMING LOGIC FROM workinglogic.html ---
                
                // Gate update logic
                if (!isResetting) {
                    let newLastRedGate = -1;
                    if (redGateCrossingTimes && redGateCrossingTimes.length > 0 && redGateCrossingTimes[0] != null && elapsedTime >= redGateCrossingTimes[0]) {
                        newLastRedGate = 0;
                        for (let i = 1; i < redGateCrossingTimes.length; i++) {
                            if (redGateCrossingTimes[i] != null && elapsedTime >= redGateCrossingTimes[i]) { newLastRedGate = i; } else { break; }
                        }
                    }
                    lastRedGate = newLastRedGate;

                    let newLastOrangeGate = -1;
                    if (orangeGateCrossingTimes && orangeGateCrossingTimes.length > 0 && orangeGateCrossingTimes[0] != null && elapsedTime >= orangeGateCrossingTimes[0]) {
                        newLastOrangeGate = 0;
                        for (let i = 1; i < orangeGateCrossingTimes.length; i++) {
                            if (orangeGateCrossingTimes[i] != null && elapsedTime >= orangeGateCrossingTimes[i]) { newLastOrangeGate = i; } else { break; }
                        }
                    }
                    lastOrangeGate = newLastOrangeGate;
                }

                // Leaderboard and interval logic
                let lastCommonGate = -1;
                for (let i = 0; i < Math.min(redGateCrossingTimes.length, orangeGateCrossingTimes.length); i++) {
                    if (
                        redGateCrossingTimes[i] != null &&
                        orangeGateCrossingTimes[i] != null &&
                        elapsedTime >= redGateCrossingTimes[i] &&
                        elapsedTime >= orangeGateCrossingTimes[i]
                    ) {
                        lastCommonGate = i;
                    } else {
                        break;
                    }
                }
                
                let isRedTheLeader = true;
                let leaderTimeVal = 0, secondTimeText = "+0.00s";

                if (lastCommonGate >= 0) {
                    const rTime = redGateCrossingTimes[lastCommonGate];
                    const oTime = orangeGateCrossingTimes[lastCommonGate];
                    if (rTime != null && oTime != null) {
                        if (rTime <= oTime) {
                            isRedTheLeader = true;
                            leaderTimeVal = rTime;
                            secondTimeText = "+" + (oTime - rTime).toFixed(2) + "s";
                        } else {
                            isRedTheLeader = false;
                            leaderTimeVal = oTime;
                            secondTimeText = "+" + (rTime - oTime).toFixed(2) + "s";
                        }
                    } else if (rTime != null) {
                        isRedTheLeader = true;
                        leaderTimeVal = rTime;
                        secondTimeText = "+0.00s";
                    } else if (oTime != null) {
                        isRedTheLeader = false;
                        leaderTimeVal = oTime;
                        secondTimeText = "+0.00s";
                    } else {
                        isRedTheLeader = true;
                        leaderTimeVal = 0;
                        secondTimeText = "+0.00s";
                    }
                } else {
                    if (lastRedGate === -1 && lastOrangeGate === -1) { isRedTheLeader = true; }
                    else if (lastRedGate === -1) { isRedTheLeader = false; }
                    else if (lastOrangeGate === -1) { isRedTheLeader = true; }
                    else {
                        if (lastOrangeGate > lastRedGate) { isRedTheLeader = false; }
                        else if (lastRedGate > lastOrangeGate) { isRedTheLeader = true; }
                        else {
                            const rTime = redGateCrossingTimes[lastRedGate];
                            const oTime = orangeGateCrossingTimes[lastOrangeGate];
                            if (rTime != null && oTime != null) { isRedTheLeader = (rTime <= oTime); }
                            else if (rTime != null) { isRedTheLeader = true; }
                            else if (oTime != null) { isRedTheLeader = false; }
                            else { isRedTheLeader = true; }
                        }
                    }
                    if (isRedTheLeader) {
                        leaderTimeVal = (lastRedGate !== -1 && redGateCrossingTimes[lastRedGate] != null) ? redGateCrossingTimes[lastRedGate] : 0;
                        if (lastOrangeGate !== -1 && orangeGateCrossingTimes[lastOrangeGate] != null) {
                            if (lastRedGate === lastOrangeGate) {
                                const diff = orangeGateCrossingTimes[lastOrangeGate] - redGateCrossingTimes[lastRedGate];
                                secondTimeText = (diff >= 0 ? "+" : "") + diff.toFixed(2) + "s";
                            } else { secondTimeText = `Gate ${lastOrangeGate + 1}`; }
                        } else { secondTimeText = "+0.00s"; }
                    } else {
                        leaderTimeVal = (lastOrangeGate !== -1 && orangeGateCrossingTimes[lastOrangeGate] != null) ? orangeGateCrossingTimes[lastOrangeGate] : 0;
                        if (lastRedGate !== -1 && redGateCrossingTimes[lastRedGate] != null) {
                            if (lastOrangeGate === lastRedGate) {
                                const diff = redGateCrossingTimes[lastRedGate] - orangeGateCrossingTimes[lastOrangeGate];
                                secondTimeText = (diff >= 0 ? "+" : "") + diff.toFixed(2) + "s";
                            } else { secondTimeText = `Gate ${lastRedGate + 1}`; }
                        } else { secondTimeText = "+0.00s"; }
                    }
                }
                
                const leaderId = isRedTheLeader ? "Red" : "Orange";

                // --- END OF UNALTERED TIMING LOGIC ---

                if (leaderDriverCell && secondDriverCell) {
                    if (isResetting || (elapsedTime < 0.01 && !isScrubbing)) {
                        // Display default state
                        leaderDriverCell.innerHTML = `<strong>${driverData["Red"].name}</strong><br><small>${driverData["Red"].team}</small>`;
                        secondDriverCell.innerHTML = `<strong>${driverData["Orange"].name}</strong><br><small>${driverData["Orange"].team}</small>`;
                        leaderTimeDOM.textContent = "0.00s"; 
                        secondTimeDOM.textContent = "0.00s";
                    } else {
                        // Use the calculated variables to update the DOM with correct names
                        const secondId = isRedTheLeader ? "Orange" : "Red";
                        const leaderInfo = driverData[leaderId];
                        const secondInfo = driverData[secondId];
                        leaderDriverCell.innerHTML = `<strong>${leaderInfo.name}</strong><br><small>${leaderInfo.team}</small>`;
                        secondDriverCell.innerHTML = `<strong>${secondInfo.name}</strong><br><small>${secondInfo.team}</small>`;
                        leaderTimeDOM.textContent = (leaderTimeVal || 0).toFixed(2) + "s";
                        secondTimeDOM.textContent = secondTimeText;
                    }
                }
                
                if (camTransActive) {
                    const alpha = Math.min((performance.now() / 1000 - camTransStart) / camTransDur, 1.0);
                    if (currentView !== 'birdsEye') updateCameraTarget();
                    camera.position.lerpVectors(camInitPos, camTargetPos, alpha);
                    camera.lookAt(new THREE.Vector3().lerpVectors(camInitLook, camTargetLook, alpha));
                    camera.up.lerpVectors(camInitUp, camInitUpTarget, alpha).normalize();
                    if (alpha >= 1.0) { camTransActive = false; camera.up.copy(camInitUpTarget); }
                } else {
                    updateCameraTarget(); camera.position.copy(camTargetPos); camera.lookAt(camTargetLook); camera.up.copy(camInitUpTarget);
                }
                renderer.render(scene, camera);
            } 
            animate(performance.now());
        } catch (error) {
            console.error('Error in animation setup:', error); 
            const errorDiv = document.createElement('div');
            errorDiv.style.color='red'; errorDiv.style.padding='20px'; errorDiv.style.textAlign='center';
            errorDiv.textContent = 'An error occurred initializing the 3D playback: ' + error.message;
            document.body.insertBefore(errorDiv, document.body.firstChild);
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Custom Lap Selector Logic
            const customLapSelectorContainer = document.getElementById('customLapSelectorContainer');
            const currentLapDisplay = document.getElementById('currentLapDisplay');
            const lapDropdownList = document.getElementById('lapDropdownList');

            if (customLapSelectorContainer && currentLapDisplay && lapDropdownList) {
                const initialTotalLaps = 72;
                let currentSelectedLapValue = 1;

                const updateLapDisplayAndAria = (current, total) => {
                    currentLapDisplay.innerHTML = `<span class="lap-text-segment">Lap </span><span class="lap-number-underlined">${current}</span><span class="lap-text-segment">/${total}</span>`;
                    currentLapDisplay.setAttribute('aria-label', `Change lap. Current selection: Lap ${current} of ${total}`);
                };

                updateLapDisplayAndAria(currentSelectedLapValue, initialTotalLaps); 

                lapDropdownList.innerHTML = ''; 
                for (let i = 1; i <= initialTotalLaps; i++) {
                    const lapOption = document.createElement('div');
                    lapOption.setAttribute('role', 'option');
                    lapOption.id = `lap-option-${i}`;
                    lapOption.textContent = `Lap ${i}`;
                    lapOption.dataset.lapNumber = i; 
                    if (i === currentSelectedLapValue) {
                        lapOption.setAttribute('aria-selected', 'true');
                        lapDropdownList.setAttribute('aria-activedescendant', lapOption.id);
                    }
                    lapOption.addEventListener('click', () => {
                        currentSelectedLapValue = parseInt(lapOption.dataset.lapNumber);
                        updateLapDisplayAndAria(currentSelectedLapValue, initialTotalLaps);
                        const currentlySelected = lapDropdownList.querySelector('[aria-selected="true"]');
                        if (currentlySelected) currentlySelected.removeAttribute('aria-selected');
                        lapOption.setAttribute('aria-selected', 'true');
                        lapDropdownList.setAttribute('aria-activedescendant', lapOption.id);
                        lapDropdownList.style.display = 'none';
                        currentLapDisplay.setAttribute('aria-expanded', 'false');
                        currentLapDisplay.focus(); 
                        console.log('Selected Lap:', currentSelectedLapValue);
                    });
                    lapDropdownList.appendChild(lapOption);
                }

                currentLapDisplay.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const isExpanded = currentLapDisplay.getAttribute('aria-expanded') === 'true';
                    lapDropdownList.style.display = isExpanded ? 'none' : 'block';
                    currentLapDisplay.setAttribute('aria-expanded', !isExpanded);
                    if (!isExpanded) {
                        const selectedOption = lapDropdownList.querySelector(`[data-lap-number="${currentSelectedLapValue}"]`) || lapDropdownList.firstChild;
                        if (selectedOption) {
                            selectedOption.classList.add('focused'); 
                            selectedOption.scrollIntoView({ block: 'nearest' });
                            lapDropdownList.setAttribute('aria-activedescendant', selectedOption.id);
                        }
                    }
                });
                
                document.addEventListener('click', (event) => {
                    if (!customLapSelectorContainer.contains(event.target) && lapDropdownList.style.display === 'block') {
                        lapDropdownList.style.display = 'none';
                        currentLapDisplay.setAttribute('aria-expanded', 'false');
                    }
                });
            }
        });
    </script>
</body>
</html>
